3.UOBIƒåAJENI PROGRAMERSKI KONCEPTI

3.1 PROMENLJIVE I MUTABILNOST

Po defoltu promeljive su imutabilne. Na ovaj naƒçin se posti≈æe bezbednost i konkurentnost. Promenljive mo≈æemo napraviti mutabilnim. Ako dodelimo vrednost nekoj promenljivoj vezanoj za  neko ime, vrednot te ptomenljive vi≈°e ne mo≈æemo da menjamo.
          fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}

Kada runujemo ovaj program, dobiƒáemo error:
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error

Ovako nam kompAjler poma≈æe da ndjemo gre≈°ke u programu. Dobili smo poruku cannot assign twice to immutable variable `x`. Rust kompajler garantuje da se promenljiva neƒáe promeniti. Ako dodamo mut keyword, promenljiva postaje mutabilna i njenu vrednost mo≈æemo menjati.
 
 fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}

Kada runujemo ovaj program dobijemo rezultat:

$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6

Na nama je da odluƒçimo da li ƒáemo koristiti mutabilnu ili imutabilnu vrednost.

KONSTANTE
Kao i konstante i promenljive su vezane za ime ime i ne mogu da se menjaju ali postoje neke razlike: Sa konstantama ne mo≈æemo da koristimo mut keyword. Konstante nisu samo imutabilne po defoltu one su uvek imutabilne. Konstante koriste const keyword i vrednosti moraju biti anotirane. Konstante mogu biti deklarisane u bilo kojem scopeu, najƒçes≈°ƒáe na globalu. Konstante mogu biti vezane jedino za constant izraz a ne za rezultat same vrednosti koje mogu biti sraƒçunate samo u runtimeu: const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; Velika slova i donja crta su Rustova naming notacija za const. Kompajleru je lak≈°e da izraƒçuna vrednost ovog izraza. Radije nego da prosledimo konkretnu vrednost koja bi bila 10,800. Konstante su validne za celukupno vreme trajanja programa u scopeu u kom su deklarisane. Nije lo≈°a praksa imati jedno mesto u kodu u kom se menja hardkodovana vrednost.

SHADOWING
U Rustu mo≈æemo da deklari≈°emo promenljivu sa istim imenom kao prethodna promenljiva. To znaƒçi da je prva promenljiva shadow-ovana od strane druge promenljive, tako da kompajler sada gleda drugu promenljivu. Promenljiva traja do kraja scopea ili dok je neka druga ne overshadowuje.

fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}

Program ce prvo odstampati 12 pa 6:

$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
Shadowing se razlikuje od mut promenljivih zato ≈°to ƒáemo dobiti compile-time error ako izostavimo let keyword. Druga razlika je da sa upotrebom let keyworda mi kreiramo novu promenljivu i reuusujemo ime a pri tom mo≈æemo i da promenimo tip promenljive. 
let spaces = "   ";
    let spaces = spaces.len();
Prva promenljiva je string druga broj.
Ukoliko upotrebimo mut na ovoj promenljivoj dobiƒáemo compile-time-error
    let mut spaces = "   ";
    spaces = spaces.len();
The error says we‚Äôre not allowed to mutate a variable‚Äôs type:

$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error



3.2 DATA TYPES 
Postoje 2 subseta tipova: skalarni i compound (slo≈æeni). Rust je staticly typed jezik tako da mora da zna tipove svih promenljivih u compile tajmu. Kompajler uglavnom mo≈æe da zakljuƒçi o kom tipu se radi na osnovu vrednosti i naƒçina kori≈°ƒáenja. U komplikovanijim sluƒçajevima treba dodati anotaciju:
let guess: u32 = "42".parse().expect("Not a number!");
Ako ne dodamo type anotaciju :u32 dobiƒáemo error koji ka≈æe da je kompajleru potrebno vi≈°e informacija:
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |
help: consider giving `guess` an explicit type
  |
2 |     let guess: _ = "42".parse().expect("Not a number!");
  |              +++

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error

SKALARNI TIPOVI
Skalarni tipovi predstavljaju pojedinaƒçnu vrednost. Rust ima primarne skalarne tipove: integere, floating pointe, numbere, booleane i karaktere. 




INTEGER TIP
Integer je ceo broj. Postoje unsigned i signed integers. 
Length	Signed	Unsigned
8-bit	i8	u8
16-bit	i16	u16
32-bit	i32	u32
64-bit	i64	u64
128-bit	i128	u128
arch	isize	usize
Svaka varijanta moze biti signed ili unsigned i ima explicitnu veliƒçinu u bajtovima. Unsigned integers imaju samo pozitivnu vrednost. Unsigned imaju samo pozitivnu vrednost jer nemaju i zato nemaju potrebu da imaju znak ispred. Svaka signed varijanta mo≈æe da storuje brojeve od ‚Äì( 2n-1 ) do 2n-1 inkluzivno, gde je n broj bitova koje varijanta koristi. Tako da i8 ƒçuva brojeve od -(27) to 27 ‚Äì 1, ≈°to je jednako -128 do 127. Unsigned varijante ƒçuvaju brojeve od 0 do 2n ‚Äì 1, tako da u8 storuje brojeve od 0 do 28 ‚Äì 1, sto je jednako 0 do 255. Isize i uszie tipovi zavise od arhitekture na≈°ih racunara. Integer literale mo≈æemo napisati na sledeƒáe naƒçine:
Number literals	Example
Decimal	98_222
Hex	0xff
Octal	0o77
Binary	0b1111_0000
Byte (u8 only)	b'A'

Mo≈æemo koristiti i donju crtu radi boljeg prikaza 1_000 je isto ≈°to i 1000. Kao defaultni tip Rust koristi i32. Isize i usize koristimo uglavnom za kolekcije.







INTEGER OVERFLOW
Ako npr imamo tip u8 koji storuje brojeve od 0 do 255, ako poku≈°amo tom tipu da dodamo vrednost 256 dogodice ƒáe se int overflow. Ovo izaziva panic u runtimeu. Ako kompjliramo sa ‚Äìrelease flagom, Rust ne radi proveru overflowa nego izvr≈°ava 2 komplementarna wrapovanja. Za vrednosti veƒáe od maximuma Rust wrapuje vrednost i pretvara u minimalni broj tog tipa. Za tip u8 za br 256 bice 0, za 257 bice 1. itd..
Program neƒáe panicovati ali neƒáemo imati vrednosti brojeva koje zelimo. Wrapping pona≈°anje mo≈æemo smatrati errorom.  Za hendlovanje overflowa mo≈æemo koristiti neke od metoda iz std biblioteke :
‚Ä¢	Wrap u svim modovima wrapping_* metode kao npr: wrapping_add.
‚Ä¢	Return none vrednost ako koristimo checked_* metode.
‚Ä¢	Vraƒáamo boolean ako koristimo overflowing_* metode.
‚Ä¢	Zasitimo metode sa min ili max vredno≈°ƒáu sa saturating_* metodama.

FLOATING POINT TIPOVI
Rust ima 2 primitivna tipa za floating-point brojeve, koji su brojevi za decimalne brojeve. Ti tipovi su f32 i f64, koji su 32 i 64 bita respektivno. Defoltni tip je f64 zato ≈°to na modernim CPUovima iste brzine kao f32 ali pru≈æa veƒáu preciznost. Svi floating point tipovi su signed. 
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}



Floating point brojevi su reprezentovani po IEEE-754 standardu. F32 je single precision float a f64 double. Floating brojevi dozvoljavaju sve matematiƒçke operacije.
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}

BOOLEAN TIP
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}	



KARAKTER TIP
Ovo je Rustov najprimitivniji alfabetski tip. 
fn main() {
    let c = 'z';
    let z: char = '‚Ñ§'; // with explicit type annotation
    let heart_eyed_cat = 'üòª';
}
Char literali koristi jednostruke navodnike naspram string literala koji koriste dvostruke. Rustov char tip je 4 bita veliƒçine i reprezentuje Unicode skalarnu vrednost. ≈†to znaƒçi da mo≈æe da reprezentuje mnogo vi≈°e nego ASCII. Validne vrednosti char-a u Rustu su i Japanska, koranska, kineska slova, emotikoni i zero-width space slova. Unicode skalarne vrednosti su u rasponu od U+0000 do U+D7FF i U+E000 do U+10FFFF inkluzivno. 

COMPOUND TIPOVI
Compound tipovi mogu da grupi≈°u vi≈°e tipova u jedan tip. Postoje 2 primitivna compound tipa: Tupple i Array.
Tupple je op≈°ti naƒçin grupisanja vi≈°e vrednosti sa razliƒçitim tipovima u jedan slo≈æeni tip. Oni imaju fiksnu du≈æinu i jednom definisani ne mogu da se poveƒáavaju ili smanjuju. Tupple defini≈°emo sa vrednostima razdvojenim zarezom, kojoj na svakoj poziciji odgovara odredjeni tip, koji ne moraju da budu isti.
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
Promenljiva tup vezuje se za ceo tupple, zato ≈°to se za tupple smatra da je jedan ceo pojedinaƒçni cpmpound element. Da pristupimo pojedinaƒçnoj vrednosti tuppla mo≈æemo da koristimo matching patern da destruktuire≈°emo vrednost tupla.
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
Elementu mo≈æemo da pristupimo i sa taƒçkom, koju prati index vrednosti kojoj ≈æelimo da pristupimo. 
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
Tupple koji ne poseduje nijednu vrednost se zove unit.  Izrazi implicitno vraƒáaju unit vrednost ako ne vraƒáaju nijednu drugu vrednost. 
NIZOVI
Jo≈° jedan naƒçin da napravimo kolekciju su nizovi ali za razliku od tupplova, nizovi moraju biti istog tipa.  Nizovi u Rustu imaju fixnu veliƒçinu. 
fn main() {
    let a = [1, 2, 3, 4, 5];
}
Nizovi su korisni ako hoƒáemo da se na≈°i podaci alociraju na stack a ne na heap ili kad ≈æelimo da uvek imamo fiksan broj elemenata. Nizovi nisu fleksibilni kao vektori. Nizovi su korisni kada znamo koliko nam taƒçno treba lemenata u kolekciji, npr meseci u godini:
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
Sintaksa za niz:
let a: [i32; 5] = [1, 2, 3, 4, 5];
Mo≈æemo napisati i ovako ako hoƒáemo da svaki element ima istu vrednost:
let a = [3; 5];
to je kevivalentno:
let a = [3, 3, 3, 3, 3];
Pristupanje elementu niza:
Niz je parƒçe koda fiksne veliƒçine na stacku tako da elementima niza mo≈æemo pristupati preko indeksa.
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}

Nepravilno pristupanje elementima niza:
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}

Ovaj kod se pravilno kompajlira. Ako ranujemo ovaj program sa cargo run, I prosledimo vrednost 0, 1, 2, 3 ili 4, isprintaƒáe se taƒçna vrednost za index tog niza. Medjutim ukoliko prosledimo vrednost izvan niza, npr. 10, konzola ƒáe ispisati :
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Program je rezultirao sa runtime erorom sa razlogom kori≈°ƒáenja netacne vrednoti za indeksing operaciju. 
Ako je index veƒái ili jednak od du≈æine niza, Rust ƒáe panikovati. Ova provera mora da se odradi u runtajmu zato ≈°to kompajler ne zna koju ƒáe vrednost user da prosledi. Ovo je primer Rustovog memory safety principa u akciji. U mnogim low level jezicima ovakva provera ne postoji, I kad prosledimo netaƒçan index, mo≈æemo da pristupimo netaƒçnoj memoriji. Rust nas stiti od ovog errora tako ≈°to odmah izlazi iz programa umesto da pristupi netaƒçnoj memoriji. 

3.3 FUNKCIJE
Keyword za funkcije je fn, main funkcija je ulazna taƒçka za mnoge programe, koja nam dozvoljava da deklari≈°emo nove funkcije. Rust koristi snake case notaciju za funckiju I promenljive tako da one poƒçinju malim slovom I odvojene su donjom crtom. 
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}

Funkciju mo≈æemo da deklari≈°emo I posle maina, bitno je samo da je u scopeu u kojem ga caller vidi. Funkcije mogu da primaju parametre ili argumente koje su konkretne vrednosti. 

fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");	
}


Kada pokrenemo program sa cargo run, dobijemo:

$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5

U funkcijama moramo deklarisati tip parametra. To je namerna odluka u dizajnu Rusta i zahtevajuƒái anotacije tipa u definiciji funkcije nam omoguƒáava da kompajler vi≈°e ne tra≈æi tip u ostatku koda I stoga ne moramo vi≈°e ad ga defini≈°emo. Kompajler takodje mo≈æe I da nam pru≈æi odgavarajuƒáe error poruke ako zna koje tipove funkcije da oƒçekuje. Vi≈°estruke parametre razdvajamo zarezima. 
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}


Kada pokrenemo ovaj kod, dobijemo:

$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h


STATEMENTI I IZRAZI
Tela funkcije se sastoje od niza izjava, statementa, koje se opciono zavr≈°avaju izrazom. 

‚Ä¢	Izjave su instrukcije koje izvr≈°avaju neku radnju I ne vraƒáaju vrednost.
‚Ä¢	Izrazi se evaluiraju do rezultante vrednosti.
‚Ä¢	
Primer izjave, statementa:
fn main() {
    let y = 6;
}
Statementi ne vraƒáaju vrednosti I samim tim ne mo≈æemo dodeliti let vrednosti drugoj promenljivoj, dobiƒáemo error.
fn main() {
    let x = (let y = 6);
}
Statement let y=6 ne vraƒáa vrednost, tako da x nema za ƒçega da se binduje. Ovo je razlika u odnosu na C i Ruby, gde dodela vraƒáa vrednost dodele i tamo mo≈æemo da napi≈°emo x = y = 6, tako da i x i y imaju vrednost 6. 
Izrazi vraƒáaju vrednost: izraz 5 + 6 evaluira vrednosti 11. Izrazi mogu biti delovi statementa: let y = 6 je izraz koji evaluira vrednost 6. Poziv funkcije izraz. Poziv macroa je izraz. Kreiranje novog blok scopea sa vitiƒçastim zagradama je izraz. 

fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {y}");
}
Blok u ovom sluƒçaju evaluira vrednost 4.
{
    let x = 3;
    x + 1
}
Vrednost se vezuje za  y kao deo let statementa. Linija koda x + 1 nema taƒçku zarez na kraju. Izrazi ne ukljuƒçuju zavr≈°nicu sa taƒçka zarezom. Ako dodamo taƒçku zarez na kraj izraza, pretvaramo ga u statement I onda neƒáe vratiti vrednost. 

FUNKCIJE SA POVRATNOM VREDNOSTI
Funkcije mogu da vrate vrednost jedino kodu koji ih poziva. Povratne vrednosti ne imenujemo ali moramo deklarisati njihov tip nakon strelice ->. U Rustu, povratne vrednost funkcije je sinonim za vrednost konaƒçnog izraza u bloku tela funkcije. Iz funkcije se mo≈æemo vratiti i ranije upotrebom return keyworda I navodjenjem vrednosti ali veƒáina funkcija implicitno vraƒáa poslednji izraz.
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}
U ovoj funckiji nema poziva funkcija, makroa pa ƒçak ni naredbi, samo broj 5, sam po sebi. Ovo je savr≈°eno validna funkcija u Rustu. Tip povratne vrednosti funkcije je i32.
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5

Pet je povratna vrednost funkcije tipa i32. Postoje dve bitne stvari: let x = five(); pokazuje da koristimo povratnu vrednost funkcije da inicijalizujemo promenljivu. Ta linija je ista kao da smo napisali: let x = 5. Drugo, funkcija zvana 5 nema parametre i defini≈°e tip povratne vrednosti ali je telo funkcije saƒçinjeno samo od broja 5 bez taƒçke zareza na kraju zato ≈°to hoƒáemo da vratimo tu vrednost. 

fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1
}



Ako runujemo ovaj kod, konzola ƒáe ispisati vrednost 6 ali ako stavimo taƒçku zarez na kraj linije x + 1 i promenimo je iz izraza u statement, dobiƒáemo error.
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}



Dobijamo sledeƒái error:
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --> src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

Error pokazuje da se tipovi ne podudaraju. Definicija funkcije ka≈æe da ƒáe vrati vrednost i32 ali statement ne evaluira vrednost izra≈æen zagradama (), unit tip. Stoga se ni≈°ta ne vraƒáa.

3.4 COMMENTS
Programeri nastoje da naƒáine svoj kod ≈°to ƒçitljivijim ali je ponekad potrebno dodatno obja≈°njenje. To se moze uƒçiniti komentarima.
// So we‚Äôre doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what‚Äôs going on.
Ili na istoj liniji kao kod.
fn main() {
    let lucky_number = 7; // I‚Äôm feeling lucky today
}

Ali najƒçe≈°ƒáe je iznad linije koda na koji se odnosi:
fn main() {
    // I‚Äôm feeling lucky today
    let lucky_number = 7;
}



3.5 CONTROL FLOW
Najƒçe≈°ƒái konstrukti koji vam omoguƒáavaju da kontroli≈°ete tok izvr≈°avanja Rust koda su if izrazi i petlje.

IF IZRAZI
If izraz nam dozvoljava da granamo na≈° kod u zavisnosti od uslova. Navedemo uslov I ka≈æemo ako je ovaj uslov ispunjen, pokrenite ovaj blok koda I obrnuto.

fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
Blokovi koda pridru≈æeni if izrazima se ponekad zovu arms. Opciono mo≈æemo da ukljuƒçimo I else izraz I damo alternativu bloku koda ako uslov evaluira false. Ako ne pru≈æimo else izraz a uslov evaluira false, program ƒáe preskoƒçiti if blok I preƒái na narednu liniju koda.


$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true	
Ako promenimo uslov:
Let number = 7;


I pokrenemo kod, dobijamo:

$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false

Uslov mora biti bool, inaƒçe dobijamo error. 

fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}

Po≈°to nemamo bool uslov, dobijamo sledeci eror:
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --> src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
Eror indikuje da Rust oƒçekuje bool a dobio je integer. Moramo eksplicitno da obezbedimo if sa booleanom kao uslov. 

HENDLOVANJE VISESTRUKIH USLOVA SA ELSE IF
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
	

Kada pokrenemo program dobijamo:
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3

I pored toga ≈°to je 6 deljivo sa 2, Rust izvr≈°ava samo blok koji va≈æi za prvi true uslov. Kori≈°ƒáenje previ≈°e else if uslova mo≈æe da uneredi kod zato je dobra praksa refaktorisati kod.


KORI≈†ƒÜENJE IF U LET STATEMENTU

Zato ≈°to je if izraz mo≈æemo ga koristiti sa desne strane let statementa da dodelimo ishod promenljivoj.

fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}

Kada pokrenemo kod dobijamo:

$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
Blokovi koda se evaluiraju prema poslednjem izrazu u njima, I brojevi su sami po sebi izrazi. U ovom sluƒçaju, vrednost celog if izraza zavisi od bloka koda koji izvr≈°ava. To znaƒçi da vrednosti koje imaju potencijal da budu rezultat svakog arma if bloka moraju biti istog tipa. Ako se tipovi razlikuju, dobiƒáemo eror:

fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {number}");
}
Kada pokrenemo kod, dobijamo eror:

$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --> src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
Ovo ne radi zato ≈°to promeljive u if else bloku moraju imati jedan tip‚Ä¶

PONAVLJANJE SA PETLJAMA
Rust ima 3 vrste petlji: loop, for, while‚Ä¶


PONAVLJANJE KODA SA LOOP PETLJOM
Loop keyword govori Rustu da izvr≈°ava blok koda iznova I iznova dok mu izriƒçito ka≈æemo da prestane.
fn main() {
    loop {
        println!("again!");
    }
}
Ovaj program ƒáe ispisivati iznova I iznova again! Dok ga ne zaustavimo ruƒçno sa ctr + c ili sa break keywordom. 

VRAƒÜANJE VREDNOSTI IZ PETLJE
Jedna od upotrebi petlje je da ponovo poku≈°amo operaciju za koju znamo da mo≈æe da fejluje, npr. Provera da li je thread zavr≈°io svoj posao. Takodje ƒáemo mo≈æda morati da prosledimo rezultat operacije iz petlje u ostatak koda. Da bismo to uradili, vrednost koju ≈æelimo da vratimo iz petlje moramo da defini≈°emo u izrazu iza break-a. 

fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}


U ovom sluƒçaju ƒáemo iz petlje vratiti vrednost 20, koja ƒáe biti zapisana u promenljivoj result.

RAZDVAJANJE VI≈†ESTRUKIH PETLJI
Ako imamo petlje unutar petlji, break I continue se primenjuju na najuntra≈°njajiju petlju. Opciono mo≈æemo da stavimo label na petlju na koju kasnije mo≈æemo da primenimo break I continue da se ne bi odnosilo na najdublju petlju. Labeli petlje moraju poƒçeti jednim navodnikom.




fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}

Spolja≈°nja petlja ima naziv ‚Äòcounting_up I inkrementovaƒáe vrednost od 0 do 2. Unutra≈°nje petlja bez oznake se dekrementuje od 10 do 9. Prvi break koji se ne odnosi na label ƒáe izaƒái iz unutra≈°nje petlje samo. Break koji se odnosi na ‚Äòcounting_up label ƒáe izaƒái samo iz spolja≈°nje petlje. Ovaj kod ƒáe printati:




$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2

KONDICIONALNE WHILE PETLJE
Program ƒçesto mora da proceni stanje unutar petlje. Dok je uslov taƒçan petlja se pokreƒáe. Kada uslov prestane da bude istinit program poziva break zaustavljajuƒái petlju. Ovakvo pona≈°anje mo≈æemo primeniti I sa loop if else break paternom ali Rust veƒá ima mplementiran konstrukt koji se zove while petlja I koji se veoma ƒçesto koristi.
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
Ovaj konstrukt elimini≈°e mnogo nestovanja koje bi nam bilo neophodno kada bi koristili if else i break. Dok je uslov taƒçan, kod se izvr≈°ava, u suprotno izlazi iz petlje.

PROLAZAK KROZ KOLEKCIJU SA FOR PETLJOM

Kroz kolekciju mo≈æemo proƒái I sa sa while petljom:
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
Kada pokrenemo program dobiƒáemo sledeƒáe:
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50


Terminal ƒáe ispisati svih 5 vrednosti zato ≈°to je 5 uslov. Da ima 6 elemenata u kolekciji, ≈°esti element ne bi ispisao. Medjutim ovaj pristup je sklon gre≈°kama jer mo≈æe izazvati panic u programu ako vrednost indeksa ili testni uslovi nisu taƒçni. Ako bi kolekcija imla 4 elemenata a ne bi promenili uslov 
while index < 4 program bi panicovao. Takodje je ovaj pristup spor jer kompajler dodaje runtime kod da izvrsi uslovnu proveru da li je index unutar granica niza na svakoj iteraciji kroz petlju. Mnogo je sa≈æetija alternativa koristi for petlju I izvr≈°iti neki kod za svaku stavku u kolekciji. 
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}

Sada ƒáemo dobiti isti output kao u prethodnom primeru ali smo sada poveƒáali bezbednost koda I eliminisali ≈°ansu za bug koji bi mogao da bude rezultat izlaska iz granica niza ili nedostizanja dovoljno daleko da bi se pristupilo nekim itemima niza. Ako koristimo for petlju ne bi morali da brinemo o promeni nekog dela koda ukoliko promenimo broj elemenata niza. 

Sigurnost I sa≈æetost for petlju ƒçine najƒçe≈°ƒáim konstruktom petlje u Rustu. ƒåak I u situacijama u kojima ≈æelimo da pokrenemo kod odredjeni broj puta kao u primeru odbrojavanja koje koriste while petlju, veƒáina Rust programera bi koristila for petlju. Naƒçin da se to uradi bio bi kori≈°ƒáenje opsega koji obezbedjuje standardna biblioteka I koja generi≈°e sve brojeve u nizu poƒçev≈°i od jednog broja I zavr≈°avajuƒái pre drugog broja.

fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}

