3.UOBIÄŒAJENI PROGRAMERSKI KONCEPTI

3.1 PROMENLJIVE I MUTABILNOST

Po defoltu promeljive su imutabilne. Na ovaj naÄin se postiÅ¾e bezbednost i konkurentnost. Promenljive moÅ¾emo napraviti mutabilnim. Ako dodelimo vrednost nekoj promenljivoj vezanoj za  neko ime, vrednot te ptomenljive viÅ¡e ne moÅ¾emo da menjamo.
          fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}

Kada runujemo ovaj program, dobiÄ‡emo error:
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error

Ovako nam kompAjler pomaÅ¾e da ndjemo greÅ¡ke u programu. Dobili smo poruku cannot assign twice to immutable variable `x`. Rust kompajler garantuje da se promenljiva neÄ‡e promeniti. Ako dodamo mut keyword, promenljiva postaje mutabilna i njenu vrednost moÅ¾emo menjati.
 
 fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}

Kada runujemo ovaj program dobijemo rezultat:

$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6

Na nama je da odluÄimo da li Ä‡emo koristiti mutabilnu ili imutabilnu vrednost.

KONSTANTE
Kao i konstante i promenljive su vezane za ime ime i ne mogu da se menjaju ali postoje neke razlike: Sa konstantama ne moÅ¾emo da koristimo mut keyword. Konstante nisu samo imutabilne po defoltu one su uvek imutabilne. Konstante koriste const keyword i vrednosti moraju biti anotirane. Konstante mogu biti deklarisane u bilo kojem scopeu, najÄesÅ¡Ä‡e na globalu. Konstante mogu biti vezane jedino za constant izraz a ne za rezultat same vrednosti koje mogu biti sraÄunate samo u runtimeu: const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; Velika slova i donja crta su Rustova naming notacija za const. Kompajleru je lakÅ¡e da izraÄuna vrednost ovog izraza. Radije nego da prosledimo konkretnu vrednost koja bi bila 10,800. Konstante su validne za celukupno vreme trajanja programa u scopeu u kom su deklarisane. Nije loÅ¡a praksa imati jedno mesto u kodu u kom se menja hardkodovana vrednost.

SHADOWING
U Rustu moÅ¾emo da deklariÅ¡emo promenljivu sa istim imenom kao prethodna promenljiva. To znaÄi da je prva promenljiva shadow-ovana od strane druge promenljive, tako da kompajler sada gleda drugu promenljivu. Promenljiva traja do kraja scopea ili dok je neka druga ne overshadowuje.

fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}

Program ce prvo odstampati 12 pa 6:

$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
Shadowing se razlikuje od mut promenljivih zato Å¡to Ä‡emo dobiti compile-time error ako izostavimo let keyword. Druga razlika je da sa upotrebom let keyworda mi kreiramo novu promenljivu i reuusujemo ime a pri tom moÅ¾emo i da promenimo tip promenljive. 
let spaces = "   ";
    let spaces = spaces.len();
Prva promenljiva je string druga broj.
Ukoliko upotrebimo mut na ovoj promenljivoj dobiÄ‡emo compile-time-error
    let mut spaces = "   ";
    spaces = spaces.len();
The error says weâ€™re not allowed to mutate a variableâ€™s type:

$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error



3.2 DATA TYPES 
Postoje 2 subseta tipova: skalarni i compound (sloÅ¾eni). Rust je staticly typed jezik tako da mora da zna tipove svih promenljivih u compile tajmu. Kompajler uglavnom moÅ¾e da zakljuÄi o kom tipu se radi na osnovu vrednosti i naÄina koriÅ¡Ä‡enja. U komplikovanijim sluÄajevima treba dodati anotaciju:
let guess: u32 = "42".parse().expect("Not a number!");
Ako ne dodamo type anotaciju :u32 dobiÄ‡emo error koji kaÅ¾e da je kompajleru potrebno viÅ¡e informacija:
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |
help: consider giving `guess` an explicit type
  |
2 |     let guess: _ = "42".parse().expect("Not a number!");
  |              +++

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error

SKALARNI TIPOVI
Skalarni tipovi predstavljaju pojedinaÄnu vrednost. Rust ima primarne skalarne tipove: integere, floating pointe, numbere, booleane i karaktere. 




INTEGER TIP
Integer je ceo broj. Postoje unsigned i signed integers. 
Length	Signed	Unsigned
8-bit	i8	u8
16-bit	i16	u16
32-bit	i32	u32
64-bit	i64	u64
128-bit	i128	u128
arch	isize	usize
Svaka varijanta moze biti signed ili unsigned i ima explicitnu veliÄinu u bajtovima. Unsigned integers imaju samo pozitivnu vrednost. Unsigned imaju samo pozitivnu vrednost jer nemaju i zato nemaju potrebu da imaju znak ispred. Svaka signed varijanta moÅ¾e da storuje brojeve od â€“( 2n-1 ) do 2n-1 inkluzivno, gde je n broj bitova koje varijanta koristi. Tako da i8 Äuva brojeve od -(27) to 27 â€“ 1, Å¡to je jednako -128 do 127. Unsigned varijante Äuvaju brojeve od 0 do 2n â€“ 1, tako da u8 storuje brojeve od 0 do 28 â€“ 1, sto je jednako 0 do 255. Isize i uszie tipovi zavise od arhitekture naÅ¡ih racunara. Integer literale moÅ¾emo napisati na sledeÄ‡e naÄine:
Number literals	Example
Decimal	98_222
Hex	0xff
Octal	0o77
Binary	0b1111_0000
Byte (u8 only)	b'A'

MoÅ¾emo koristiti i donju crtu radi boljeg prikaza 1_000 je isto Å¡to i 1000. Kao defaultni tip Rust koristi i32. Isize i usize koristimo uglavnom za kolekcije.







INTEGER OVERFLOW
Ako npr imamo tip u8 koji storuje brojeve od 0 do 255, ako pokuÅ¡amo tom tipu da dodamo vrednost 256 dogodice Ä‡e se int overflow. Ovo izaziva panic u runtimeu. Ako kompjliramo sa â€“release flagom, Rust ne radi proveru overflowa nego izvrÅ¡ava 2 komplementarna wrapovanja. Za vrednosti veÄ‡e od maximuma Rust wrapuje vrednost i pretvara u minimalni broj tog tipa. Za tip u8 za br 256 bice 0, za 257 bice 1. itd..
Program neÄ‡e panicovati ali neÄ‡emo imati vrednosti brojeva koje zelimo. Wrapping ponaÅ¡anje moÅ¾emo smatrati errorom.  Za hendlovanje overflowa moÅ¾emo koristiti neke od metoda iz std biblioteke :
â€¢	Wrap u svim modovima wrapping_* metode kao npr: wrapping_add.
â€¢	Return none vrednost ako koristimo checked_* metode.
â€¢	VraÄ‡amo boolean ako koristimo overflowing_* metode.
â€¢	Zasitimo metode sa min ili max vrednoÅ¡Ä‡u sa saturating_* metodama.

FLOATING POINT TIPOVI
Rust ima 2 primitivna tipa za floating-point brojeve, koji su brojevi za decimalne brojeve. Ti tipovi su f32 i f64, koji su 32 i 64 bita respektivno. Defoltni tip je f64 zato Å¡to na modernim CPUovima iste brzine kao f32 ali pruÅ¾a veÄ‡u preciznost. Svi floating point tipovi su signed. 
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}



Floating point brojevi su reprezentovani po IEEE-754 standardu. F32 je single precision float a f64 double. Floating brojevi dozvoljavaju sve matematiÄke operacije.
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}

BOOLEAN TIP
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}	



KARAKTER TIP
Ovo je Rustov najprimitivniji alfabetski tip. 
fn main() {
    let c = 'z';
    let z: char = 'â„¤'; // with explicit type annotation
    let heart_eyed_cat = 'ğŸ˜»';
}
Char literali koristi jednostruke navodnike naspram string literala koji koriste dvostruke. Rustov char tip je 4 bita veliÄine i reprezentuje Unicode skalarnu vrednost. Å to znaÄi da moÅ¾e da reprezentuje mnogo viÅ¡e nego ASCII. Validne vrednosti char-a u Rustu su i Japanska, koranska, kineska slova, emotikoni i zero-width space slova. Unicode skalarne vrednosti su u rasponu od U+0000 do U+D7FF i U+E000 do U+10FFFF inkluzivno. 

COMPOUND TIPOVI
Compound tipovi mogu da grupiÅ¡u viÅ¡e tipova u jedan tip. Postoje 2 primitivna compound tipa: Tupple i Array.
Tupple je opÅ¡ti naÄin grupisanja viÅ¡e vrednosti sa razliÄitim tipovima u jedan sloÅ¾eni tip. Oni imaju fiksnu duÅ¾inu i jednom definisani ne mogu da se poveÄ‡avaju ili smanjuju. Tupple definiÅ¡emo sa vrednostima razdvojenim zarezom, kojoj na svakoj poziciji odgovara odredjeni tip, koji ne moraju da budu isti.
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
Promenljiva tup vezuje se za ceo tupple, zato Å¡to se za tupple smatra da je jedan ceo pojedinaÄni cpmpound element. Da pristupimo pojedinaÄnoj vrednosti tuppla moÅ¾emo da koristimo matching patern da destruktuireÅ¡emo vrednost tupla.
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
Elementu moÅ¾emo da pristupimo i sa taÄkom, koju prati index vrednosti kojoj Å¾elimo da pristupimo. 
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
Tupple koji ne poseduje nijednu vrednost se zove unit.  Izrazi implicitno vraÄ‡aju unit vrednost ako ne vraÄ‡aju nijednu drugu vrednost. 
NIZOVI
JoÅ¡ jedan naÄin da napravimo kolekciju su nizovi ali za razliku od tupplova, nizovi moraju biti istog tipa.  Nizovi u Rustu imaju fixnu veliÄinu. 
fn main() {
    let a = [1, 2, 3, 4, 5];
}
Nizovi su korisni ako hoÄ‡emo da se naÅ¡i podaci alociraju na stack a ne na heap ili kad Å¾elimo da uvek imamo fiksan broj elemenata. Nizovi nisu fleksibilni kao vektori. Nizovi su korisni kada znamo koliko nam taÄno treba lemenata u kolekciji, npr meseci u godini:
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
Sintaksa za niz:
let a: [i32; 5] = [1, 2, 3, 4, 5];
MoÅ¾emo napisati i ovako ako hoÄ‡emo da svaki element ima istu vrednost:
let a = [3; 5];
to je kevivalentno:
let a = [3, 3, 3, 3, 3];
Pristupanje elementu niza:
Niz je parÄe koda fiksne veliÄine na stacku tako da elementima niza moÅ¾emo pristupati preko indeksa.
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}

Nepravilno pristupanje elementima niza:
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}

Ovaj kod se pravilno kompajlira. Ako ranujemo ovaj program sa cargo run, I prosledimo vrednost 0, 1, 2, 3 ili 4, isprintaÄ‡e se taÄna vrednost za index tog niza. Medjutim ukoliko prosledimo vrednost izvan niza, npr. 10, konzola Ä‡e ispisati :
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Program je rezultirao sa runtime erorom sa razlogom koriÅ¡Ä‡enja netacne vrednoti za indeksing operaciju. 
Ako je index veÄ‡i ili jednak od duÅ¾ine niza, Rust Ä‡e panikovati. Ova provera mora da se odradi u runtajmu zato Å¡to kompajler ne zna koju Ä‡e vrednost user da prosledi. Ovo je primer Rustovog memory safety principa u akciji. U mnogim low level jezicima ovakva provera ne postoji, I kad prosledimo netaÄan index, moÅ¾emo da pristupimo netaÄnoj memoriji. Rust nas stiti od ovog errora tako Å¡to odmah izlazi iz programa umesto da pristupi netaÄnoj memoriji. 

3.3 FUNKCIJE
Keyword za funkcije je fn, main funkcija je ulazna taÄka za mnoge programe, koja nam dozvoljava da deklariÅ¡emo nove funkcije. Rust koristi snake case notaciju za funckiju I promenljive tako da one poÄinju malim slovom I odvojene su donjom crtom. 
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}

Funkciju moÅ¾emo da deklariÅ¡emo I posle maina, bitno je samo da je u scopeu u kojem ga caller vidi. Funkcije mogu da primaju parametre ili argumente koje su konkretne vrednosti. 

fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");	
}


Kada pokrenemo program sa cargo run, dobijemo:

$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5

U funkcijama moramo deklarisati tip parametra. To je namerna odluka u dizajnu Rusta i zahtevajuÄ‡i anotacije tipa u definiciji funkcije nam omoguÄ‡ava da kompajler viÅ¡e ne traÅ¾i tip u ostatku koda I stoga ne moramo viÅ¡e ad ga definiÅ¡emo. Kompajler takodje moÅ¾e I da nam pruÅ¾i odgavarajuÄ‡e error poruke ako zna koje tipove funkcije da oÄekuje. ViÅ¡estruke parametre razdvajamo zarezima. 
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}


Kada pokrenemo ovaj kod, dobijemo:

$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h


STATEMENTI I IZRAZI
Tela funkcije se sastoje od niza izjava, statementa, koje se opciono zavrÅ¡avaju izrazom. 

â€¢	Izjave su instrukcije koje izvrÅ¡avaju neku radnju I ne vraÄ‡aju vrednost.
â€¢	Izrazi se evaluiraju do rezultante vrednosti.
â€¢	
Primer izjave, statementa:
fn main() {
    let y = 6;
}
Statementi ne vraÄ‡aju vrednosti I samim tim ne moÅ¾emo dodeliti let vrednosti drugoj promenljivoj, dobiÄ‡emo error.
fn main() {
    let x = (let y = 6);
}
Statement let y=6 ne vraÄ‡a vrednost, tako da x nema za Äega da se binduje. Ovo je razlika u odnosu na C i Ruby, gde dodela vraÄ‡a vrednost dodele i tamo moÅ¾emo da napiÅ¡emo x = y = 6, tako da i x i y imaju vrednost 6. 
Izrazi vraÄ‡aju vrednost: izraz 5 + 6 evaluira vrednosti 11. Izrazi mogu biti delovi statementa: let y = 6 je izraz koji evaluira vrednost 6. Poziv funkcije izraz. Poziv macroa je izraz. Kreiranje novog blok scopea sa vitiÄastim zagradama je izraz. 

fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {y}");
}
Blok u ovom sluÄaju evaluira vrednost 4.
{
    let x = 3;
    x + 1
}
Vrednost se vezuje za  y kao deo let statementa. Linija koda x + 1 nema taÄku zarez na kraju. Izrazi ne ukljuÄuju zavrÅ¡nicu sa taÄka zarezom. Ako dodamo taÄku zarez na kraj izraza, pretvaramo ga u statement I onda neÄ‡e vratiti vrednost. 

FUNKCIJE SA POVRATNOM VREDNOSTI
Funkcije mogu da vrate vrednost jedino kodu koji ih poziva. Povratne vrednosti ne imenujemo ali moramo deklarisati njihov tip nakon strelice ->. U Rustu, povratne vrednost funkcije je sinonim za vrednost konaÄnog izraza u bloku tela funkcije. Iz funkcije se moÅ¾emo vratiti i ranije upotrebom return keyworda I navodjenjem vrednosti ali veÄ‡ina funkcija implicitno vraÄ‡a poslednji izraz.
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}
U ovoj funckiji nema poziva funkcija, makroa pa Äak ni naredbi, samo broj 5, sam po sebi. Ovo je savrÅ¡eno validna funkcija u Rustu. Tip povratne vrednosti funkcije je i32.
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5

Pet je povratna vrednost funkcije tipa i32. Postoje dve bitne stvari: let x = five(); pokazuje da koristimo povratnu vrednost funkcije da inicijalizujemo promenljivu. Ta linija je ista kao da smo napisali: let x = 5. Drugo, funkcija zvana 5 nema parametre i definiÅ¡e tip povratne vrednosti ali je telo funkcije saÄinjeno samo od broja 5 bez taÄke zareza na kraju zato Å¡to hoÄ‡emo da vratimo tu vrednost. 

fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1
}



Ako runujemo ovaj kod, konzola Ä‡e ispisati vrednost 6 ali ako stavimo taÄku zarez na kraj linije x + 1 i promenimo je iz izraza u statement, dobiÄ‡emo error.
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}



Dobijamo sledeÄ‡i error:
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --> src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

Error pokazuje da se tipovi ne podudaraju. Definicija funkcije kaÅ¾e da Ä‡e vrati vrednost i32 ali statement ne evaluira vrednost izraÅ¾en zagradama (), unit tip. Stoga se niÅ¡ta ne vraÄ‡a.

3.4 COMMENTS
Programeri nastoje da naÄ‡ine svoj kod Å¡to Äitljivijim ali je ponekad potrebno dodatno objaÅ¡njenje. To se moze uÄiniti komentarima.
// So weâ€™re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain whatâ€™s going on.
Ili na istoj liniji kao kod.
fn main() {
    let lucky_number = 7; // Iâ€™m feeling lucky today
}

Ali najÄeÅ¡Ä‡e je iznad linije koda na koji se odnosi:
fn main() {
    // Iâ€™m feeling lucky today
    let lucky_number = 7;
}



3.5 CONTROL FLOW
NajÄeÅ¡Ä‡i konstrukti koji vam omoguÄ‡avaju da kontroliÅ¡ete tok izvrÅ¡avanja Rust koda su if izrazi i petlje.

IF IZRAZI
If izraz nam dozvoljava da granamo naÅ¡ kod u zavisnosti od uslova. Navedemo uslov I kaÅ¾emo ako je ovaj uslov ispunjen, pokrenite ovaj blok koda I obrnuto.

fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
Blokovi koda pridruÅ¾eni if izrazima se ponekad zovu arms. Opciono moÅ¾emo da ukljuÄimo I else izraz I damo alternativu bloku koda ako uslov evaluira false. Ako ne pruÅ¾imo else izraz a uslov evaluira false, program Ä‡e preskoÄiti if blok I preÄ‡i na narednu liniju koda.


$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true	
Ako promenimo uslov:
Let number = 7;


I pokrenemo kod, dobijamo:

$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false

Uslov mora biti bool, inaÄe dobijamo error. 

fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}

PoÅ¡to nemamo bool uslov, dobijamo sledeci eror:
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --> src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
Eror indikuje da Rust oÄekuje bool a dobio je integer. Moramo eksplicitno da obezbedimo if sa booleanom kao uslov. 

HENDLOVANJE VISESTRUKIH USLOVA SA ELSE IF
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
	

Kada pokrenemo program dobijamo:
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3

I pored toga Å¡to je 6 deljivo sa 2, Rust izvrÅ¡ava samo blok koji vaÅ¾i za prvi true uslov. KoriÅ¡Ä‡enje previÅ¡e else if uslova moÅ¾e da uneredi kod zato je dobra praksa refaktorisati kod.


KORIÅ Ä†ENJE IF U LET STATEMENTU

Zato Å¡to je if izraz moÅ¾emo ga koristiti sa desne strane let statementa da dodelimo ishod promenljivoj.

fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}

Kada pokrenemo kod dobijamo:

$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
Blokovi koda se evaluiraju prema poslednjem izrazu u njima, I brojevi su sami po sebi izrazi. U ovom sluÄaju, vrednost celog if izraza zavisi od bloka koda koji izvrÅ¡ava. To znaÄi da vrednosti koje imaju potencijal da budu rezultat svakog arma if bloka moraju biti istog tipa. Ako se tipovi razlikuju, dobiÄ‡emo eror:

fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {number}");
}
Kada pokrenemo kod, dobijamo eror:

$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --> src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
Ovo ne radi zato Å¡to promeljive u if else bloku moraju imati jedan tipâ€¦

PONAVLJANJE SA PETLJAMA
Rust ima 3 vrste petlji: loop, for, whileâ€¦


PONAVLJANJE KODA SA LOOP PETLJOM
Loop keyword govori Rustu da izvrÅ¡ava blok koda iznova I iznova dok mu izriÄito kaÅ¾emo da prestane.
fn main() {
    loop {
        println!("again!");
    }
}
Ovaj program Ä‡e ispisivati iznova I iznova again! Dok ga ne zaustavimo ruÄno sa ctr + c ili sa break keywordom. 

VRAÄ†ANJE VREDNOSTI IZ PETLJE
Jedna od upotrebi petlje je da ponovo pokuÅ¡amo operaciju za koju znamo da moÅ¾e da fejluje, npr. Provera da li je thread zavrÅ¡io svoj posao. Takodje Ä‡emo moÅ¾da morati da prosledimo rezultat operacije iz petlje u ostatak koda. Da bismo to uradili, vrednost koju Å¾elimo da vratimo iz petlje moramo da definiÅ¡emo u izrazu iza break-a. 

fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}


U ovom sluÄaju Ä‡emo iz petlje vratiti vrednost 20, koja Ä‡e biti zapisana u promenljivoj result.

RAZDVAJANJE VIÅ ESTRUKIH PETLJI
Ako imamo petlje unutar petlji, break I continue se primenjuju na najuntraÅ¡njajiju petlju. Opciono moÅ¾emo da stavimo label na petlju na koju kasnije moÅ¾emo da primenimo break I continue da se ne bi odnosilo na najdublju petlju. Labeli petlje moraju poÄeti jednim navodnikom.




fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}

SpoljaÅ¡nja petlja ima naziv â€˜counting_up I inkrementovaÄ‡e vrednost od 0 do 2. UnutraÅ¡nje petlja bez oznake se dekrementuje od 10 do 9. Prvi break koji se ne odnosi na label Ä‡e izaÄ‡i iz unutraÅ¡nje petlje samo. Break koji se odnosi na â€˜counting_up label Ä‡e izaÄ‡i samo iz spoljaÅ¡nje petlje. Ovaj kod Ä‡e printati:




$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2

KONDICIONALNE WHILE PETLJE
Program Äesto mora da proceni stanje unutar petlje. Dok je uslov taÄan petlja se pokreÄ‡e. Kada uslov prestane da bude istinit program poziva break zaustavljajuÄ‡i petlju. Ovakvo ponaÅ¡anje moÅ¾emo primeniti I sa loop if else break paternom ali Rust veÄ‡ ima mplementiran konstrukt koji se zove while petlja I koji se veoma Äesto koristi.
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
Ovaj konstrukt eliminiÅ¡e mnogo nestovanja koje bi nam bilo neophodno kada bi koristili if else i break. Dok je uslov taÄan, kod se izvrÅ¡ava, u suprotno izlazi iz petlje.

PROLAZAK KROZ KOLEKCIJU SA FOR PETLJOM

Kroz kolekciju moÅ¾emo proÄ‡i I sa sa while petljom:
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
Kada pokrenemo program dobiÄ‡emo sledeÄ‡e:
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50


Terminal Ä‡e ispisati svih 5 vrednosti zato Å¡to je 5 uslov. Da ima 6 elemenata u kolekciji, Å¡esti element ne bi ispisao. Medjutim ovaj pristup je sklon greÅ¡kama jer moÅ¾e izazvati panic u programu ako vrednost indeksa ili testni uslovi nisu taÄni. Ako bi kolekcija imla 4 elemenata a ne bi promenili uslov 
while index < 4 program bi panicovao. Takodje je ovaj pristup spor jer kompajler dodaje runtime kod da izvrsi uslovnu proveru da li je index unutar granica niza na svakoj iteraciji kroz petlju. Mnogo je saÅ¾etija alternativa koristi for petlju I izvrÅ¡iti neki kod za svaku stavku u kolekciji. 
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}

Sada Ä‡emo dobiti isti output kao u prethodnom primeru ali smo sada poveÄ‡ali bezbednost koda I eliminisali Å¡ansu za bug koji bi mogao da bude rezultat izlaska iz granica niza ili nedostizanja dovoljno daleko da bi se pristupilo nekim itemima niza. Ako koristimo for petlju ne bi morali da brinemo o promeni nekog dela koda ukoliko promenimo broj elemenata niza. 

Sigurnost I saÅ¾etost for petlju Äine najÄeÅ¡Ä‡im konstruktom petlje u Rustu. ÄŒak I u situacijama u kojima Å¾elimo da pokrenemo kod odredjeni broj puta kao u primeru odbrojavanja koje koriste while petlju, veÄ‡ina Rust programera bi koristila for petlju. NaÄin da se to uradi bio bi koriÅ¡Ä‡enje opsega koji obezbedjuje standardna biblioteka I koja generiÅ¡e sve brojeve u nizu poÄevÅ¡i od jednog broja I zavrÅ¡avajuÄ‡i pre drugog broja.

fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}

