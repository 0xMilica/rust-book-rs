
1.	GETTING STARTED 

1.2	Hello world 

fn main() { 
println!("Hello, world!"); 
} 

Komande za pokretanje programa:

rustc main.rs 
.\main.exe 
Hello, world! 

Anatomija Rust programa: 

fn main() { 
} 

Main funkcija se uvek prva izvršava u Rust programu. Telo funkcije se nalazi u vitičastim zagradama. Unutar tela f-je se nalazi print funkcija. Ono što primećujemo je da se u Rust-u kôd uvlači sa 4 razmaka, a ne pomoću tab-a. S obzirom na to da je println! makro funkcija, kao takva ima drugačija pravila od običnih funkcija. Izraze završavamo sa ; i tako sledeći može da počne. Uglavnom sve linije kôda u Rust-u završavaju sa ; . 


Kompajliranje i pokretanje(running) su odvojeni koraci 

Prvo moramo da kompajliramo kod i za to koristimo komandu rustc i prosledjdujemo fajl koji hoćemo da se kompajlira, na primer: rustc main.rs. Ako je kompajliranje uspešno, pojaviće se 3 fajla: main.exe (executable file), main.pdb (debugging extenzija) i main.rs (source file). Kompajlirani fajl pokrećemo pomoću komande .\main.exe koja će izvršiti program. 
Rust je 'ahead-of-time compiled' jezik, što znači da možemo da kompajliramo program možemo da damo nekom drugom, i taj neko može da pokrene program bez da instalira Rust, što nije slučaj sa drugim jezicima, kao što je Python. Kompjliranje samo sa rustc komandom je u redu za manje programe, ali kako projekat raste, poželjno je imati više opcija, za šta nam treba Cargo tooling. 

1.3 Hello Cargo 

Cargo je build sistem i package manager. On rukovodi bildovanjem projekata, download-ovanjem biblioteka (dependency-ja) i gradjenje sopstvenih biblioteka. Cargo dolazi instaliran sa Rust-om. Može se proveriti da li je instaliran pomoću pokretanja komande 'cargo –version'. 
Kreiranje projekta sa Cargom: $ cargo new hello_cargo, cd hello_cargo. Cargo je definisao 2 fajla i jedan folder: cargo.toml fajl i src folder koji sadrži main.rs fajl. Takodje je inicijalizovao git repozitorije sa .gitignore fajlom. Git fajlovi neće biti generisani sa komandom cargo new u postojećem git repozitorijumu. Možemo da overrajdujejmo ovo ponašanje sa komandom cargo new --vcs=git. Pomoću –vcs biramo da ne koristimo version control. 



Cargo.toml 

[package] 
name = "hello_cargo" 
version = "0.1.0" 
edition = "2021" 

TOML (Tom’s Obvious, Minimal Language) - konfiguracioni format Cargo-a. 
Prva linija [package] je section heading i navodi statement-e koji definišu paket. 
Linija [dependencies] definise spoljašnje zavisnosti. 
Pakete kôda u Rust-u nazivamo Crates. 
Cargo očekuje da naši source fajlovi budu uskladišteni u src folderu. Top level folder namenjen je za read.me fajl, informacije o licenci (ukoliko postoji), konfiguracione fajlove, itd. 


BUILDING AND RUNNING CARGO PROJECT 

Komanda Cargo build: 

cargo build 
Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo) 
Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs 

Ova komanda kreira izvršni fajl u target\debug\hello_cargo.exe. Cargo smešta binary u debug folder. Executable možemo da pokrenemo pomoću sledeće komande: 
.\target\debug\hello_cargo.exe 
Kada pokrenemo Cargo build prvi put on kreira cargo.lock u top level folderu. On vodi računa o tačnim verzijama dependency-ja u našem projektu. Cargo automatski rukovodi ovim za nas. 
Možemo da koristimo komandu Cargo Run koja će istovremeno kompajlirati i pokrenuti naš kôd. 

cargo run 
Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs 
Running `target/debug/hello_cargo` 
Hello, world! 

Cargo run je dosta uobičajeniji način za pokretanje našeg kôda. 
Ukoliko promenimo izvorni kôd, cargo će rebildovati kôd i dobićemo drugačiju poruku: 

cargo run 
Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo) 
Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs 
Running `target/debug/hello_cargo` 
Hello, world! 


Cargo check je komanda koja brzo proverava da li se naš kôd kompajlira (a ne proizvodi executable). 

cargo check 
Checking hello_cargo v0.1.0 (file:///projects/hello_cargo) 
Finished dev [unoptimized + debuginfo] target(s) in 0.32 sec 

Check je zgodan zato što je mnogo brži od builda zato što ne proizvodi executable. Na ovaj način možemo da ubrzamo proces našeg rada zato što konstantno proveravamo da li se naš kod kompjlira. Na kraju kad smo spremni da napravimo executable runujemo build. 

Upotreba Cargo-a: 

• Kreiramo projekte sa cargo new 
• Buildujemo projekte sa cargo build 
• Buildujemo I runujemo projekte sa cargo run 
• Proveravamo da li se kod kompajlira sa cargo check bez da proizvodimo executable. 
• Cargo čuva rezultate u target/build folderu 



BUILDING FOR RELEASE 

Kada je program spreman za release koristimo komandu build –release da ga kompajliramo sa optimizacijom. Ova komanda će stvoriti exectuble u target/release folderu umesto target/debug folderu. Optimizacija čini naš program bržim ali je I vreme kompajliranja duže. Zato postoje 2 različita profila: jedan za development kada rebildujemo brzo I često I jedan za build finalnog programa koji ćemo predati useru I koji se neće rebildovati ali ce biti veoma brz. 


CARGO KONVENCIJE 

Za jednostavne programe dovoljno je da koristimo rustc ali čim program počne da raste treba da koristimo cargo. Iako Hello Cargo program deluje jednostavno, on obuhvata sav potreban tooling koji nam treba. 
Ako radimo na nekom postojećem projektu, možemo da proverimo kod koristeci Git, kloniramo taj projekat prebacimo se u njegov folder I bildujemo: 

git clone example.org/someproject 
cd someproject 
cargo build 

Za više informacija pogledati dokumentaciju. 


SUMMARY 

Rustup koristimo da instaliramo poslednju stablinu verziju Rusta.
Updajtejemo noviju verziju.
